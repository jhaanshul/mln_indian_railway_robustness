# -*- coding: utf-8 -*-
"""MLN_PROJECT.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gndzynPU36OXmrDVIqOhn7QLu0KU1rxK
"""

from google.colab import drive
drive.mount('/content/gdrive')

import random
import networkx as nx
import collections
import matplotlib.pyplot as plt
import numpy
import math
from matplotlib import pyplot as plt

def isLocalTrain(lines, i, cur_train):    #checks whether the cur_train is a local train or express
  temp = cur_train
  while(temp==cur_train and i < len(lines)-1):
    i+=1
    if(lines[i].split(",")[0]!="K"):
      cur_train = lines[i].split(",")[0]
  distance_travelled = None
  try:
    distance_travelled = int(lines[i-1].split(",")[7])
    if(distance_travelled < 250):
      return (True, i)
  except:
    print("inside: "+lines[i-1])
  return (False, None)

# def remove_local_train_from_graph(G, pos, lines, train):
#   last_train = None
#   cur_train = None
#   cur_station = None
#   cur_distance = None
#   last_station = None
#   last_distance = None
#   for i in range(pos, 0, -1):
#     l = lines[i]
#     l = l.split(",")
#     if(l[0]=="K"):  ##some entries in the csv have improper entries 
#       continue
#     cur_train = l[0]
#     cur_station = l[3]
#     if(cur_train==last_train):
#       G.remove_edge(cur_station, last_station)
#     elif(last_train!=None):
#       return
#     last_train = cur_train
#     last_station = cur_station

trains = set()
with open('/content/gdrive/My Drive/MLN_Project/Train_details_22122017.csv') as f:
  lines = f.readlines()[1:]
  for i in range(len(lines)):
    l = lines[i]
    l = l.split(",")
    if(l[0]=="K"):  ##some entries in the csv have improper entries 
      continue
    cur_train = l[0]
    trains.add(cur_train)

len(trains)

"""#below code for generating the graph. Local trains are not included in the network for better clarity of the network."""

G = nx.DiGraph()
locals = 0
edge_to_train_map = {}   #contains the list of trains passing throug each edge
train_details_map = {}   #contains the loss related to each train as the log of the distance covered by it

with open('/content/gdrive/My Drive/MLN_Project/Train_details_22122017.csv') as f:
  lines = f.readlines()[1:]
  last_train = None
  cur_train = None
  cur_station = None
  cur_distance = None
  last_station = None
  last_distance = None
  for i in range(len(lines)):
    l = lines[i]
    l = l.split(",")
    if(l[0]=="K"):  ##some entries in the csv have improper entries 
      continue
    cur_train = l[0]
    cur_station = l[3]
    (isLocal, index) = isLocalTrain(lines, i, cur_train)
    if(isLocal):
      locals += 1
      i = index
      continue

    try:
      cur_distance = int(l[7])
    except:
      print("exception :"+ str(l))
    
    if(cur_train==last_train):
      edge_data = G.get_edge_data(last_station, cur_station)
      count = 1 if edge_data==None else (edge_data['weight'] + 1)
      G.add_edge(last_station,cur_station, weight = count)
      if((last_station, cur_station) in edge_to_train_map):
        edge_to_train_map[(last_station, cur_station)].append(cur_train)
      else:
        trains = []
        trains.append(cur_train)
        edge_to_train_map[(last_station, cur_station)] = trains

    else:
      # if(last_distance!=None and last_distance < 250 ):
      #   #remove_local_train_from_graph(G, i-1, lines, last_train)
      #   locals += 1
      # else:
        try:
          train_details_map[last_train] = math.log(last_distance)
        except:
          print(last_distance)
    last_train = cur_train
    last_station = cur_station
    last_distance = cur_distance

G.number_of_nodes()

G.number_of_edges()

# def plot_degree_sequence(graphs): #takes input as a dictionary with key as graph and value as the color in plot
#   for G in graphs.keys():
#     degree_sequence = sorted([d for n, d in G.degree()], reverse=False)
#     d = {} #dictionary for maintaing the count of each degree
#     for deg in degree_sequence:
#       if deg in d:
#         d[deg] = d[deg] + 1
#       else:
#         d[deg] = 1
#     y = numpy.log10(list(d.values()))
#     x = numpy.log10(list(d.keys()))
#     plt.plot(x,y, color=graphs[G])
#   plt.xlabel('degree log')
#   plt.ylabel('count log')
#   plt.title('Degree Distribution')
#   plt.show()

# plot_degree_sequence({G: 'red'})

def plot_degree_sequence(G):
  degree_sequence = sorted([d for n, d in G.out_degree()], reverse=False)
  d = {}
  for deg in degree_sequence:
    if deg in d:
      d[deg] = d[deg] + 1
    else:
      d[deg] = 1
  y = numpy.log10(list(d.values()))
  x = numpy.log10(list(d.keys()))
  # par = numpy.polyfit( x[1:], y[1:], 1, full=True )
  # c=par[0][1]
  # m=par[0][0]
  # yfit = [c + m * xi for xi in x]
  plt.scatter(x,y, color='green')
  #plt.plot(x,yfit)
  plt.xlabel('degree log')
  plt.ylabel('count log')
  plt.title('Degree Distribution')
  plt.show()

plot_degree_sequence(G)

plot_degree_sequence(G)

"""Following section implements the influenece maximization algorithm for retrieving the most relevant edges in the network"""

def total_loss(train_details_map):
  values = train_details_map.values()
  sum = 0
  for v in values:
    sum += v
  return sum

total_loss_ = total_loss(train_details_map)   #total_loss_ stroring the total loss if all trains are stopped running

total_loss_

def get_edge_loss(edge, cur_set, train_details_map, edge_to_train_map):
  loss = 0
  for train in edge_to_train_map[edge]:
    if train not in cur_set:
      try:
        loss += train_details_map[train]
      except:
        loss += 0
  return loss

def maximize_influence(G, k , train_details_map, edge_to_train_map):
  cur_set = set()
  total_loss = 0
  result = []
  for i in range(k):
    max_edge = None
    max_loss = 0
    for edge in G.edges():
      edge_loss = get_edge_loss(edge, cur_set, train_details_map, edge_to_train_map)
      if(edge_loss > max_loss):
        max_edge = edge
        max_loss = edge_loss
    #print(max_edge)
    total_loss += max_loss
    result.append(total_loss)
    try:
      cur_set.update(set(edge_to_train_map[max_edge])) #add to the set, the list of train destroyed through 
      G.remove_edge(max_edge[0], max_edge[1])
    except:
      x = 0
  return result

result = maximize_influence(G, G.number_of_edges(), train_details_map, edge_to_train_map)

#plt.scatter(range(len(result)),result, color='green')
plt.plot(range(1000),result[0:1000], color='green')
#plt.ylim(total_loss_)
plt.xlabel('Edges')
plt.ylabel('Loss')
plt.title('Robustness')
plt.show()

